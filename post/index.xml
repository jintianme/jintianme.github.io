<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Lewis Jin</title>
    <link>https://jintianme.github.io/post/index.xml</link>
    <description>Recent content in Posts on Lewis Jin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 18 Jan 2017 22:59:15 +0800</lastBuildDate>
    <atom:link href="https://jintianme.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>hugo a new blog</title>
      <link>https://jintianme.github.io/post/hugo-a-new-blog/</link>
      <pubDate>Wed, 18 Jan 2017 22:59:15 +0800</pubDate>
      
      <guid>https://jintianme.github.io/post/hugo-a-new-blog/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;this post is something about blog migration from hexo to hugo, it the same thing, but you know, I&amp;rsquo;d like search new things all the time.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;usage-of-hugo&#34;&gt;Usage of hugo&lt;/h3&gt;

&lt;p&gt;hugo is more complicated then hexo, I think, but it&amp;rsquo;s more flexable however. Here is the general step of using hugo:
* start a site first
* start a post
* select a theme
* generate public files
* push it on github&lt;/p&gt;

&lt;p&gt;Ok, I am going write down those step one by one.
For start a site, you gonna install hugo first, if you are using mac, you can install by brew:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you can use &lt;code&gt;hugo&lt;/code&gt; commond start a site:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo new site ~/Documents/myblog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then, you can start a post for test:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo new post/my-first-post-on-hugo.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ok, then you have to clone a theme on github,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd themes
git clone https://github.com/pdevty/material-design
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then you just get a material-design theme in your themes folder.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ..
hugo server --theme=material-design buildDrafts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you can see your blog on browser on &lt;code&gt;127.0.0.1:1313&lt;/code&gt;,
&lt;img src=&#34;https://raw.githubusercontent.com/pdevty/material-design/master/images/tn.png&#34; alt=&#34;sample blog&#34; /&gt;
All right, you must remember this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo --theme=material-design --baseUrl=&amp;quot;http://yourpage.github.io/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;above commod is using generate static files of your site. then:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd public
git init
git add .
git commit -a -m &amp;quot;init commit&amp;quot;
git remote add origin http://github.com/yourpage/yourpage.github.io.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And of course you can see your blog on &lt;code&gt;http://yourpage.github.io&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;some-notes&#34;&gt;Some Notes&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;You must set baseUrl in your config.atoml file&lt;/strong&gt;
If you don&amp;rsquo;t, you may not see your site properly, it maybe have no css style!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;That&amp;rsquo;s All&lt;/strong&gt;
Enjoy your new hugo blog!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Django 3 分分钟搭建一个RESTful API</title>
      <link>https://jintianme.github.io/post/Django-3-%E5%88%86%E5%88%86%E9%92%9F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AARESTful-API/</link>
      <pubDate>Mon, 16 Jan 2017 23:31:58 +0000</pubDate>
      
      <guid>https://jintianme.github.io/post/Django-3-%E5%88%86%E5%88%86%E9%92%9F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AARESTful-API/</guid>
      <description>

&lt;h3 id=&#34;django-restframework-简介&#34;&gt;Django restframework 简介&lt;/h3&gt;

&lt;p&gt;时间过得好快，不知不觉这就是Django系列教程的第三部分了，这部分我们将在一分钟之内用django的一个第三方框架-Django restframework搭建我们的第一个api。首先闲话不多说让我们先安装一下这个框架：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo pip3 install django-restframework
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ok，安装完之后能让我们新建一个project吧&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;django-admin startproject ara
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着新建一个app：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python3 manage.py startapp users
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ok这时候我们的项目结构应该是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── ara
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── users
    ├── __init__.py
    ├── admin.py
    ├── apps.py
    ├── models.py
    ├── tests.py
    └── views.py

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ok，简单易懂，接着还是我们配置一下restframework吧&lt;/p&gt;

&lt;h3 id=&#34;restframework配置&#34;&gt;Restframework配置&lt;/h3&gt;

&lt;p&gt;配置这个框架请依照这个步骤来，缺一不可：
- &lt;strong&gt;在settings.py中我们install一下&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSTALLED_APPS = [
    &#39;django.contrib.admin&#39;,
    &#39;django.contrib.auth&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.sessions&#39;,
    &#39;django.contrib.messages&#39;,
    &#39;django.contrib.staticfiles&#39;,
    &#39;users&#39;,
    &#39;rest_framework&#39;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;在settings.py中添加这个&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# using rest_framework setting this line
REST_FRAMEWORK = {
# Use Django&#39;s standard `django.contrib.auth` permissions,
# or allow read-only access for unauthenticated users.
&#39;DEFAULT_PERMISSION_CLASSES&#39;: [
    &#39;rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly&#39;
]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ok，经过这个配置之后，我们就可以在项目中import restframework了。接下来我要向同志们展示一下这个东西到底有多么吊炸天！&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;三步搞定一套api-增删改查&#34;&gt;三步搞定一套API，增删改查！&lt;/h3&gt;

&lt;p&gt;我说过只用三步，那我们就分三步来。
- &lt;strong&gt;第1步：&lt;/strong&gt; 当然是新建一个models&lt;/p&gt;

&lt;p&gt;二话不多说直接复制粘贴代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 -*-
from django.db import models


# Create your models here.
class User(models.Model):
    &amp;quot;&amp;quot;&amp;quot;
    name: name of user,
    gender: user&#39;s gender
    wechat: user&#39;s wechat
    &amp;quot;&amp;quot;&amp;quot;
    name = models.CharField(max_length=100, blank=False)
    gender = models.CharField(max_length=4, blank=True)
    birthday = models.DateField(blank=True)
    portrait_url = models.CharField(max_length=100, blank=True)
    home = models.CharField(max_length=20, blank=True)
    phone = models.CharField(max_length=17, blank=True)
    email = models.CharField(max_length=20, blank=True)
    wechat = models.CharField(max_length=20, blank=True)
    company = models.CharField(max_length=20, blank=True)
    occupation = models.CharField(max_length=20, blank=True)
    living_city = models.CharField(max_length=20, blank=True)

    def __str__(self):
        return self.name
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第2步：&lt;/strong&gt; 在app下新建serializers.py，写入这些代码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;二话不多说直接复制粘贴代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from rest_framework import serializers, viewsets
from users.models import User


class UsersSerializer(serializers.ModelSerializer):

    class Meta:
        model = User
        fields = &#39;__all__&#39;


# ViewSets define the view behavior.
class UsersViewSet(viewsets.ModelViewSet):
    queryset = User.objects.all()
    serializer_class = UsersSerializer

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里我们实现一个UsersSerializers以及一个UsersViewSet这两个类，这个序列化函数暂且不知道是干毛的，但是很显然这个函数的作用是把从数据库中查询的结果序列化为字符串。不过重点是这个ViewSet，这个东西就这么几行代码它就帮你实现好了增、删、改、查的所有功能。不是吹牛逼等一下我们来验证看看是不是。
你会惊奇的发现，有了这个ViewSet之后我们都不用写view.py了！！！！！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第3步：&lt;/strong&gt; 配置urls
二话不多说直接复制粘贴代码：
```
from django.conf.urls import url, include
from django.contrib import admin
from users.serializers import UsersViewSet
from rest_framework import routers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;router = routers.DefaultRouter()
router.register(r&amp;rsquo;api/v1/users&amp;rsquo;, UsersViewSet)&lt;/p&gt;

&lt;p&gt;urlpatterns = [
    url(r&amp;rsquo;^admin/&amp;lsquo;, admin.site.urls),
    url(r&amp;rsquo;^api-auth/&amp;lsquo;, include(&amp;lsquo;rest_framework.urls&amp;rsquo;, namespace=&amp;lsquo;rest_framework&amp;rsquo;)),
    url(r&amp;rsquo;^&amp;lsquo;, include(router.urls))
]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;配置urls要用到restframework中的router这个类，这个是一个路由器，或者说是分发器，request的网址分发过来我发给哪个view处理就有他来决定，但是很显然这里并没有发给任何一个view，而是直接发给了一个ViewSet，这个ViewSet结合我们的serializer就可以实现我们的返回json或者接受json的全套功能！就是这么的屌！屌的爆炸！！
好吧，最后说一下urlpatterns里面的几个pattern，第一个是admin不需要多说，重点是最后一个我们include了router的urls，所以说你只需要按照router的网址来写即可，不过重点是router还实现了一个隐士查询也就是你可以加具体数字查询具体的detail。

### Django restframework测试！
说了这么多来测试一下呗！！我们输入：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://127.0.0.1:8000/api/v1/users&#34;&gt;http://127.0.0.1:8000/api/v1/users&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;看看返回的结果：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTTP 200 OK
Allow: GET, POST, OPTIONS
Content-Type: application/json
Vary: Accept&lt;/p&gt;

&lt;p&gt;[
    {
        &amp;ldquo;id&amp;rdquo;: 1,
        &amp;ldquo;name&amp;rdquo;: &amp;ldquo;金天&amp;rdquo;,
        &amp;ldquo;gender&amp;rdquo;: &amp;ldquo;男&amp;rdquo;,
        &amp;ldquo;birthday&amp;rdquo;: &amp;ldquo;1993-12-11&amp;rdquo;,
        &amp;ldquo;portrait_url&amp;rdquo;: &amp;ldquo;&lt;a href=&#34;https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1593523098,2479335990&amp;amp;fm=116&amp;amp;gp=0.jpg&amp;quot;&#34;&gt;https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1593523098,2479335990&amp;amp;fm=116&amp;amp;gp=0.jpg&amp;quot;&lt;/a&gt;,
        &amp;ldquo;home&amp;rdquo;: &amp;ldquo;江西南昌&amp;rdquo;,
        &amp;ldquo;phone&amp;rdquo;: &amp;ldquo;15116123160&amp;rdquo;,
        &amp;ldquo;email&amp;rdquo;: &amp;ldquo;1195889656@qq.com&amp;rdquo;,
        &amp;ldquo;wechat&amp;rdquo;: &amp;ldquo;jintianilveu&amp;rdquo;,
        &amp;ldquo;company&amp;rdquo;: &amp;ldquo;&amp;rdquo;,
        &amp;ldquo;occupation&amp;rdquo;: &amp;ldquo;&amp;rdquo;,
        &amp;ldquo;living_city&amp;rdquo;: &amp;ldquo;&amp;rdquo;
    },
    {
        &amp;ldquo;id&amp;rdquo;: 2,
        &amp;ldquo;name&amp;rdquo;: &amp;ldquo;Elgins&amp;rdquo;,
        &amp;ldquo;gender&amp;rdquo;: &amp;ldquo;男&amp;rdquo;,
        &amp;ldquo;birthday&amp;rdquo;: &amp;ldquo;1994-11-02&amp;rdquo;,
        &amp;ldquo;portrait_url&amp;rdquo;: &amp;ldquo;&amp;rdquo;,
        &amp;ldquo;home&amp;rdquo;: &amp;ldquo;&amp;rdquo;,
        &amp;ldquo;phone&amp;rdquo;: &amp;ldquo;&amp;rdquo;,
        &amp;ldquo;email&amp;rdquo;: &amp;ldquo;&amp;rdquo;,
        &amp;ldquo;wechat&amp;rdquo;: &amp;ldquo;&amp;rdquo;,
        &amp;ldquo;company&amp;rdquo;: &amp;ldquo;&amp;rdquo;,
        &amp;ldquo;occupation&amp;rdquo;: &amp;ldquo;&amp;rdquo;,
        &amp;ldquo;living_city&amp;rdquo;: &amp;ldquo;&amp;rdquo;
    }
]
```
在网页中你可以直接测试POST PUT GET等方法，总是很牛逼有没有！！分分钟做一套API啊！！比java web快出了不知道多少倍！！！明天我们继续深入探测这个东西！！！！！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Django 2 MySQL and Blog</title>
      <link>https://jintianme.github.io/post/Django-2-MySQL-and-Blog/</link>
      <pubDate>Sun, 15 Jan 2017 18:14:45 +0000</pubDate>
      
      <guid>https://jintianme.github.io/post/Django-2-MySQL-and-Blog/</guid>
      <description>

&lt;h3 id=&#34;mysql-usage&#34;&gt;mysql usage&lt;/h3&gt;

&lt;p&gt;In this post I am going writting some useful commonds of mysql, hand this you can operate Database as cake.
1. &lt;strong&gt;Change specific database encode&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ALTER DATABASE ara CHARACTER SET utf8;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Change all database encode&lt;/strong&gt;
```
SET CHARACTER_SET_CONNECTTION=utf8;
SET CHARACTER_SET_DATABASE=utf8;
SET CHARACTER_SET_SERVER=utf8;
SET CHARACTER_SET_CLIENT=utf8;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;
3. **Ultimate method to change encode of mysql**
ok, I have to admmit that above method you cannot really change mysql&#39;s encode, it still be latin1 for character_database and character_server. But using this you can change the encode method forever. First of all, please make sure you have stop mysql.
**Step 1**
copy `my-default.cnf` to `/etc/my.cnf`, using:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cp /usr/local/mysql/support-files/my-default.cnf /etc/my.cnf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
**Step 2**
changing a exactly right to that file, make sure only you can write and read it, using:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sudo chmod 644 my.cnf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;**Step 3**
add this lines to the file:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sudo vim my.cnf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[client]
default-character-set=utf8&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;under `[mysqld]` adding this:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;default-storage-engine=INNODB
character-set-server=utf8
collation-server=utf8_general_ci&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ok, then save and quit, start mysql, and you will find:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql&amp;gt; show variables like &amp;ldquo;%char%&amp;rdquo;;
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
| Variable_name            | Value                                                   |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
| character_set_client     | utf8                                                    |
| character_set_connection | utf8                                                    |
| character_set_database   | utf8                                                    |
| character_set_filesystem | binary                                                  |
| character_set_results    | utf8                                                    |
| character_set_server     | utf8                                                    |
| character_set_system     | utf8                                                    |
| character_sets_dir       | /usr/local/mysql-5.7.16-osx10.11-x86_64/share/charsets/ |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
8 rows in set (0.01 sec)
```&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Django之歌-Post 1 Django和mysql</title>
      <link>https://jintianme.github.io/post/Django%E4%B9%8B%E6%AD%8C-Post-1-Django-%E5%92%8C-mysql/</link>
      <pubDate>Thu, 12 Jan 2017 20:31:45 +0000</pubDate>
      
      <guid>https://jintianme.github.io/post/Django%E4%B9%8B%E6%AD%8C-Post-1-Django-%E5%92%8C-mysql/</guid>
      <description>

&lt;p&gt;这个post是讲述django和mysql的故事，记录django常用命令以及mysql的python接口安装方法，环境为python3.6。
&lt;!-- more --&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;本文由作者金天原创，欢迎大家转载，不过请保留这段版权信息，多谢合作，如对本文有任何问题欢迎联系作者: jintianiloveu&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;django大法&#34;&gt;Django大法&lt;/h3&gt;

&lt;p&gt;作为一位极客，不会点服务端还真不行，现在什么都离不开云啊，最近一直想建站，app接口也要用到云，本来打算用java，可是想了一下java即使使用框架访问数据库的效率还是有点低，而我呢，python玩得这么6，人生苦短啊为何不用python，反正都是事先一样的东西，我们做的也不是淘宝天猫，不需要考虑太多并发的东西，因此从某种意义上来讲，使用django是一个非常不错的选择。好了闲话不多说，这是一个&lt;strong&gt;django之歌&lt;/strong&gt;的系列，既然是歌那就得分乐章，不分逻辑了。&lt;/p&gt;

&lt;h3 id=&#34;django命令&#34;&gt;Django命令&lt;/h3&gt;

&lt;p&gt;Django的安装就不多说了，安装好python，比如mac下&lt;code&gt;brew install pyton3&lt;/code&gt;就ok了，再次必须说明一下，我不太喜欢过时的东西，但是太新意味着踩坑，所以大家要做好踩坑的准备。Django安装好之后就可以直接用了，这里我收集一下django入门会用到的命令吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;django-admin startproject deepx
python3 manage.py startapp article
python3 manage.py runserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个命令是新建项目，第二个新建一个app，这里一个app其实就是项目中的一个功能模块，在我看来。
新建好的django一般是这样的工程目录：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── article
│   ├── __init__.py
│   ├── __pycache__
│   │   └── __init__.cpython-36.pyc
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   └── __init__.py
│   ├── models.py
│   ├── tests.py
│   └── views.py
├── lewisblog
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-36.pyc
│   │   └── settings.cpython-36.pyc
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── manage.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里article就是app，lewisblog是整个工程的名字。&lt;/p&gt;

&lt;h3 id=&#34;django和mysql&#34;&gt;Django和mysql&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;UPDATE&lt;/strong&gt;
这里增加一下，很多人说python3.6 安装mysql报错，解决方法是python3安装&lt;strong&gt;mysqlclient&lt;/strong&gt;，网上很多方法都是过时，其他mysql的驱动并不适用python3，大家注意了啊！
可以说这是一对好拍档，很多人说django自带的sqlite就很不错啊，使得sqlite很方便不用安装不用配置，数据库文件就在工程的目录下，访问简单快捷，但是呢，sqlite并太轻了，我们还是使用mysql吧，毕竟比较流行，而且一些语句也是我们常用的语句，因此可以说mysql是非常合适不过的啦。在配置mysql的时候要在上面的&lt;code&gt;settings.py&lt;/code&gt;中设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,
        &#39;NAME&#39;: &#39;lewisblog&#39;,
        &#39;USER&#39;: &#39;root&#39;,
        &#39;PASSWORD&#39;: &#39;root&#39;,
        &#39;HOST&#39;: &#39;127.0.0.1&#39;,
        &#39;PORT&#39;: &#39;3306&#39;,
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ok,在这里我们就设置好了数据库引擎以及数据库的名字和密码之类的东西，当然要想链接上数据库还得再mysql中新建则个数据库，数据库名字随便取罗。然后我们要干啥？对了这个settings，在你新建了一个app之后记得在这里登记一下，这里可以控制是哪些app有效。&lt;/p&gt;

&lt;h3 id=&#34;django和model&#34;&gt;Django和Model&lt;/h3&gt;

&lt;p&gt;很多人都说DJango是一个template，为什么这么说，思考一下，很多其他库做后台操作数据库都免不了要写一些数据库查询语句，增删改查都要连接数据库查询有没有然后增删改，但是这样做的效率其实是非常低的。很多不必要的操作都是在这里产生的。
而Django在这个地方就不同，它自己实现一个很强大的基类，就是model，这就是一个数据库模型，在model里面你可以找到数据库里面的各种数据类型，甚至在时间的操作上比数据库还简单。比如我们要写一个article的表，我们不用再数据库里面建了，建好了然后在写一个数据类，这在java里面你就得干这个脏活，但是在django里你就不需要重复无意义的事情了，&lt;strong&gt;你只需要建一个model&lt;/strong&gt;，然后migrate一下，你就可以在mysql中看到你新建的表了。怎么样方便吧，哎写了这么多肚子有饿了。看来明天得好好吃一顿了。
贴一个model新建的类的代码：(在上面的app下面的models.py中)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from django.db import models


# Create your models here.
class Article(models.Model):
    title = models.CharField(max_length=100, blank=True)
    category = models.CharField(max_length=50, blank=True)
    author = models.CharField(max_length=50, blank=True)
    date_time = models.DateTimeField(auto_now_add=True)
    content = models.TextField(blank=True, null=True)

    def __unicode__(self):
        return self.title

    class Meta:
        ordering = [&#39;-date_time&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看看，所见即所得，你一旦实现了这个model之后你就不用管mysql了，以后插入数据什么的只需要实现这个类就行了，简直是方便的有点蛋疼啊！
新建了这个model之后，你要把这个应用到mysql需要下面两条啊语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python3 manage.py makemigrations
python3 manage,py migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一条意思是我把model在本地生成一个migrations文件夹，里面要记录你对数据的操作，而第二个命令就是你对这个操作施加到数据库中。两条命令按顺序执行才能deploy到数据库里面，这时候打开mysql就可以看到我们的表了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; USE lewisblog;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql&amp;gt; SHOW TABLES;
+----------------------------+
| Tables_in_lewisblog        |
+----------------------------+
| article_article            |
| auth_group                 |
| auth_group_permissions     |
| auth_permission            |
| auth_user                  |
| auth_user_groups           |
| auth_user_user_permissions |
| django_admin_log           |
| django_content_type        |
| django_migrations          |
| django_session             |
+----------------------------+
11 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到没，我们的模型已经转换成表了。6不6！！！&lt;/p&gt;

&lt;h3 id=&#34;django的mysql-shell&#34;&gt;Django的mysql shell&lt;/h3&gt;

&lt;p&gt;其实Django内置了一个shell，在这个shell里面你可以模拟mysql对数据库进行增删改查，但是呢，要进入这个shell还是得默默的进入，不要让任何人知道：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python3 manage.py shell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入shell，这是一个神奇的地方，我们执行以下这个命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from article.models import Article
&amp;gt;&amp;gt;&amp;gt; Article.objects.create(title = &#39;hello world.&#39;, category = &#39;django&#39;, author = &#39;Lewis Jin&#39;, content = &#39;Today I leared Django and it is very nice!&#39;)                                                                                         
&amp;lt;Article: Article object&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着你甚至不用migrate就可以直接在mysql中查看到我们已经成功地添加了一条记录在数据库中！你就说6不6！！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; mysql&amp;gt; SELECT * FROM article_article;
+----+--------------+----------+-----------+----------------------------+--------------------------------------------+
| id | title        | category | author    | date_time                  | content                                    |
+----+--------------+----------+-----------+----------------------------+--------------------------------------------+
|  1 | hello world. | django   | Lewis Jin | 2017-01-12 13:25:13.273888 | Today I leared Django and it is very nice! |
+----+--------------+----------+-----------+----------------------------+--------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是增，改和删也很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = Article.objects.get(id=1)
&amp;gt;&amp;gt;&amp;gt; a.title
&#39;hello world.&#39;
&amp;gt;&amp;gt;&amp;gt; a.title = &#39;Hello World&#39;
&amp;gt;&amp;gt;&amp;gt; a.title
&#39;Hello World&#39;
&amp;gt;&amp;gt;&amp;gt; a.delete()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;本篇章结语&#34;&gt;本篇章结语&lt;/h3&gt;

&lt;p&gt;基本上看完这些就可以入门了，接下来我们更加深入的剖析django，我们要充分利用这个利器，来实现我们想要的web程序，让云变的触手可及！！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Yolo训练自己的数据集教程 Newest(2016-12-23)</title>
      <link>https://jintianme.github.io/post/Yolo%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%E6%95%99%E7%A8%8B-Newest-2016-12-23/</link>
      <pubDate>Thu, 22 Dec 2016 18:27:38 +0000</pubDate>
      
      <guid>https://jintianme.github.io/post/Yolo%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%E6%95%99%E7%A8%8B-Newest-2016-12-23/</guid>
      <description>

&lt;h2 id=&#34;yolo-darknet训练自己的数据集教程-newest-2016-12-23&#34;&gt;Yolo darknet训练自己的数据集教程(Newest 2016.12.23)&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;经过两天的折腾终于搞定了Yolo训练自己的数据集的过程，整个过程其实并不繁琐，只是网上一些过时的教程已经不适用了，依照那个反而让大家各种出出错，加之Yolo中文教程过少，因此本大神再次放一个，如果大家有任何问题直接在文章后面评论即可，笔者看到之后给予第一时间回复。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;先插一句，Atom中文不能跟随窗口wrap文字的同学，打开settingview，设置soft wrap即可，百度上的答案真的是渣&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;yolo简介&#34;&gt;Yolo简介&lt;/h3&gt;

&lt;p&gt;在训练数据集之前，相信大家对yolo应该有一些了解，本文所采用的测试环境为：Ubuntu 16.04 + opencv2.4 + cuda8 + cudnn5.1 PLUS GTX1080，当然这个硬件不是必须，在下只是偶尔装一下逼。Yolo基于darknet编写，而编译draknet的时候最好安装一下opencv，因为没有opencv图不会自动弹出，没有那种快感，你懂得，不知道如何安装opencv的同学去我之前写的几个博客中搜寻。均能够找到最新的答案。&lt;/p&gt;

&lt;p&gt;yolo之所以快，是因为它的方法和fastrcnn以及其他detect算法不同，而采用了很多ssd的思想，在最新的更新中，yolo也改进了他们的算法，在pascal voc数据集上取得了不错的结果。本文将主要利用yolo来做realtime detect，对自己的数据进行训练和预测。&lt;/p&gt;

&lt;h3 id=&#34;开始开车&#34;&gt;开始开车&lt;/h3&gt;

&lt;p&gt;OK，闲话不多说，让我们直接上车，这次是无人驾驶，速度比较快，大家系好安全带。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 1 编译darknet，并熟悉目录结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;第一部分没有什么说的，很简单其实，首先clone代码到本地~目录：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~
git clone https://github.com/pjreddie/darknet
cd darknet
make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候我们在home根目录就有了darknet了。直接编译，不需要修改任何参数，当然如何你是土豪，你有GTX1080,像我一样（手动装比）。可以编译一下Makefile里面的参数。为了防止大家出错我还是说一下，直接改标志为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GPU=1
CUDNN=1
OPENCV=0
DEBUG=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你的cuda没有设置环境变量，nvcc的路径也设置一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NVCC=/usr/local/cuda/bin/nvcc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不要想的很复杂其实很简单。ok，现在直接make，编译就可以了。&lt;/p&gt;

&lt;p&gt;**Step 2 准备自己的数据集 **&lt;/p&gt;

&lt;p&gt;好了我们现在有了darktnet，但是我要那个匡出物体的掉炸天的图怎么搞？莫慌，我们先用darknet自带的测试数据来测试一下。
首先呢，yolo这个网络是训练VOC数据集得来的，20中物体都能识别出来，我们直接下载已经训练好的权重然后来预测一张图片看看：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://pjreddie.com/media/files/yolo.weights
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时候我们就下载好了yolo.weights，在darknet目录下。然后我们就可以用这个权重来预测啦！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./darknet detect cfg/yolo.cfg yolo.weights data/dog.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;detect命令意思是，检测，后面还有i一个命令是detector train，后者是训练的命令，预测用detect，cfg/yolo.cfg就是yolo这个网络的结构文件，后面是权重，最后后面是图片。
ok，enter你就可以看到狗和自行车了！～
这就搞定了darknet，那么问题来了。自己的数据集怎么准备呢？
重点来了重点来了：
* images 准备&lt;/p&gt;

&lt;p&gt;首先，把你的图片放到一个/images 文件夹下面，文件名的名字要有规律，比如0001.jpg,0002.jpg&amp;hellip;.0100.jpg;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;xml 准备&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我相信很多人都需要用图片标注工具来对图片生成标注信息来训练，但是图片标注工具生成的多半是xml的标签信息。darknet需要的label并不是xml格式，而是一张图片一个txt的形式，txt中是你标注的物体方框坐标。后面我会放出几个脚本来处理。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;xml 转 darknet label&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;xml转为darknet需要的label形式，一张图片一个标注信息。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;生成图片路径
最后一部我们要生成两个txt文件，一个是train.txt,一个是valid.txt，train.txt包含了你训练图片需要的图片路径，没一行都是一张图片的路径，为了防止出错，后面我放出一个统一的脚本生成这个train.txt。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Step 3 训练之前修改darknet参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接下来就要修改darknet的参数了，只要修改/cfg/voc.data 文件，因为yolo是为了voc而存在的，为了不修改源代码的情况下来训练我们的数据，建议直接修改voc.data而不是修改voc.data文件名。修改内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;classes= 20
train  = /home/pjreddie/data/voc/train.txt
valid  = /home/pjreddie/data/voc/2007_test.txt
names = data/voc.names
backup = /home/pjreddie/backup/

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，classes就是你数据集的类别，names你的新建一个，在data下面，然后在这里指向它，仿照voc.names 新建即可。
修改train.txt valid.txt的路径，用绝对路径哦，防止出错，因为你darknet和数据可能不再一个目录。
ok，这就setup完了，接着直接训练。
不过训练之前获取一个预处理的权重：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -O http://pjreddie.com/media/files/darknet19_448.conv.23
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，train：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./darknet detector train cfg/voc.data cfg/yolo-voc.cfg darknet19_448.conv.23
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对了，如果你上面改了voc.data的文件名，这里也要改，所以说其实改也是可以的。然后yolo-voc.cfg就可以不改了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 4 yolo训练出的模型预测&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./darknet detect cfg/yolo-voc.cfg /backup/voc.weights data/sample.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里不要和直接copy我的代码，cfg/yolo-voc.cfg就是我们训练的网络。后面是训练保存的权重，最后是你要预测的图片。
OK，看看结果咋么样～&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu14.04 or 16.04 Nvidia GTX1080 搭建CUDA过程</title>
      <link>https://jintianme.github.io/post/Ubuntu14-04-or-16-04-Nvidia-GTX1080-%E6%90%AD%E5%BB%BACUDA%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Sat, 17 Dec 2016 11:02:30 +0000</pubDate>
      
      <guid>https://jintianme.github.io/post/Ubuntu14-04-or-16-04-Nvidia-GTX1080-%E6%90%AD%E5%BB%BACUDA%E8%BF%87%E7%A8%8B/</guid>
      <description>&lt;p&gt;一定要ssh远程登录
关闭开启图形界面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo service lightdm start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到后面可能换会出现 NVIDIA driver install - Error: Unable to find the kernel source tree的错误，解决办法
sudo update-grub
uname -r
会显示当前内核&lt;/p&gt;

&lt;p&gt;cd /usr/src
会有kernel的位置&lt;/p&gt;

&lt;p&gt;卸载Nvidia驱动
sudo nvidia-uninstall&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Auto Drive Series 2-YOLO state-of-arts algrithm learn and Pascal VOC</title>
      <link>https://jintianme.github.io/post/Auto-Drive-Series-2-YOLO-state-of-arts-algrithm-learn-and-Pascal-VOC/</link>
      <pubDate>Fri, 16 Dec 2016 14:22:12 +0000</pubDate>
      
      <guid>https://jintianme.github.io/post/Auto-Drive-Series-2-YOLO-state-of-arts-algrithm-learn-and-Pascal-VOC/</guid>
      <description>

&lt;p&gt;This post about YOLO algrithm: you only look once.
&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;These days I am search on the auto drive things, here is the recording of the rearch process.
&amp;gt; 本文由中南大学较为牛逼的研究生金天同学原创，欢迎转载，但是请保留这段版权信息，如果你对文章有任何疑问，欢迎微信联系我：jintianiloveu。牛逼大神一一为你解答！&lt;/p&gt;

&lt;h3 id=&#34;yolo-you-only-look-once&#34;&gt;YOLO-you only look Once&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://pjreddie.com/darknet/yolo/&#34;&gt;yolo&lt;/a&gt;
&lt;a href=&#34;http://host.robots.ox.ac.uk/pascal/VOC/voc2012/index.html#devkit&#34;&gt;Pascal VOC&lt;/a&gt;
&lt;a href=&#34;http://mscoco.org/dataset/#overview&#34;&gt;coco test-dev&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Autodrive Series 1-kitti dataset search</title>
      <link>https://jintianme.github.io/post/Autodrive-Series-1-kitti-dataset-search/</link>
      <pubDate>Fri, 16 Dec 2016 13:08:17 +0000</pubDate>
      
      <guid>https://jintianme.github.io/post/Autodrive-Series-1-kitti-dataset-search/</guid>
      <description>

&lt;p&gt;This post about auto drive
&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;These days I am search on the auto drive things, here is the recording of the rearch process.
&amp;gt; 本文由中南大学较为牛逼的研究生金天同学原创，欢迎转载，但是请保留这段版权信息，如果你对文章有任何疑问，欢迎微信联系我：jintianiloveu。牛逼大神一一为你解答！&lt;/p&gt;

&lt;h3 id=&#34;kitti-dataset-intro&#34;&gt;kitti Dataset Intro&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cvlibs.net/datasets/kitti/&#34;&gt;kitti dataset&lt;/a&gt; include a lot of data, such as flow and object detection and tracking. This part mainly about object detect. First we work on the data of object tracking. This data have lots of stereo images. Lots of orginaization have benchmark on the data. My work is reimplement the benchmark source code for the dataset.&lt;/p&gt;

&lt;h3 id=&#34;kitti-object-detection-benchmark&#34;&gt;kitti object detection benchmark&lt;/h3&gt;

&lt;p&gt;this benchmark implement is a little difficult. First of all, we have Detection data and Ground Truth data. Detection data can be describe as follow:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Car -1 -1 2.010000 670.401855 173.185532 725.845154 198.735275 -1 -1 -1 -1 -1 -1 -1 0.99683654308319091796875000000000

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;every colomuns means:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Values    Name      Description
----------------------------------------------------------------------------
   1    frame        Frame within the sequence where the object appearers
   1    track id     Unique tracking id of this object within this sequence
   1    type         Describes the type of object: &#39;Car&#39;, &#39;Van&#39;, &#39;Truck&#39;,
                     &#39;Pedestrian&#39;, &#39;Person_sitting&#39;, &#39;Cyclist&#39;, &#39;Tram&#39;,
                     &#39;Misc&#39; or &#39;DontCare&#39;
   1    truncated    Float from 0 (non-truncated) to 1 (truncated), where
                     truncated refers to the object leaving image boundaries.
		     Truncation 2 indicates an ignored object (in particular
		     in the beginning or end of a track) introduced by manual
		     labeling.
   1    occluded     Integer (0,1,2,3) indicating occlusion state:
                     0 = fully visible, 1 = partly occluded
                     2 = largely occluded, 3 = unknown
   1    alpha        Observation angle of object, ranging [-pi..pi]
   4    bbox         2D bounding box of object in the image (0-based index):
                     contains left, top, right, bottom pixel coordinates
   3    dimensions   3D object dimensions: height, width, length (in meters)
   3    location     3D object location x,y,z in camera coordinates (in meters)
   1    rotation_y   Rotation ry around Y-axis in camera coordinates [-pi..pi]
   1    score        Only for results: Float, indicating confidence in
                     detection, needed for p/r curves, higher is better.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have to mark that for occluded means this detected box has been hidden by something. alpha means angle of camera toward the detect object.&lt;/p&gt;

&lt;h3 id=&#34;hardest-part&#34;&gt;Hardest part&lt;/h3&gt;

&lt;p&gt;The Hardest part is caculate overlap and Accuracy and Recall. In here, I got the overlap by a every simple python script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def calculate_overlap(box_detect, box_ground_truth, on_which=0):
    # 计算overlap，返回重叠率，根据on_which标志位计算是否是相对于union区域还是分别相对于box_a,box_b
    # on_which = -1，0，1 分别表示相对于重合面积，相对于检测区域，相对于ground_truth区域
    assert len(box_detect) == 4 and len(box_ground_truth) == 4, &#39;overlap 计算要求box必须有四维数据&#39;
    assert on_which != -1 or on_which != 0 or on_which != -1, &#39;on_which 必须是-1，0，1&#39;

    # 计算overlap
    # 在计算overlap的时候要注意，一定要判断两个区域是否相交，如果丝毫不想交直接略过不计算
    ol_x1 = max(box_detect[0], box_ground_truth[0])
    ol_y1 = max(box_detect[1], box_ground_truth[1])
    ol_x2 = min(box_detect[2], box_ground_truth[2])
    ol_y2 = min(box_detect[3], box_ground_truth[3])

    ol_weight = ol_x2 - ol_x1
    ol_height = ol_y2 - ol_y1

    if ol_weight &amp;lt;= 0 or ol_height &amp;lt;= 0:
        return 0
    else:
        ol_area = ol_weight * ol_height
        box_detect_area = abs(box_detect[0] - box_detect[2]) * abs(box_detect[1] - box_detect[3])
        box_ground_truth_area = abs(box_ground_truth[0] - box_ground_truth[2]) * abs(
            box_ground_truth[1] - box_ground_truth[3])
        box_all_union = box_detect_area + box_ground_truth_area - ol_area
        if on_which == -1:
            return ol_area / box_all_union
        elif on_which == 0:
            return ol_area / box_detect_area
        elif on_which == 1:
            return ol_area / box_ground_truth
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;this is the function of calculate_overlap.It returns the overlap rate of detect box.
and then, we have to caculate accuracy and recall:
&lt;strong&gt;Accuracy&lt;/strong&gt;
this word means how precision of my predict.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;accuracy = TP/(TP + FP)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;this means, accuacy calculate the percent of your right object in your all &lt;strong&gt;right object&lt;/strong&gt;.
&lt;strong&gt;Recall&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;recall = TP/(TP + FN)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;this means, recall calculate the percent of your right object in your all &lt;strong&gt;object in origin sample&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Concret Example&lt;/strong&gt;
In a pool we have 1400 iPhone, 500 Xiaomi Note2, and 400 Sansumg Galaxy S7 Edge. Now we want grab the iPhone in the pool, we grab a net and we got 300 iPhone, 200 Xiaomi Note2, and 100 Sansumg Galaxy S7 Edge. We can calculate our goal like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;accuacy = 300/(300 + 200 + 100) = 50%
recall = 300/1400 = 3/14 = 21%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;so we have the conclusion:
&lt;strong&gt;Sometimes we just get one iPhone and we have 100% accuracy, but the recall is very low&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;above-all&#34;&gt;Above all&lt;/h3&gt;

&lt;p&gt;Next station You Only Look Once, a new algrithm on the way.&lt;/p&gt;

&lt;h3 id=&#34;add-2016-12-16&#34;&gt;&lt;strong&gt;Add 2016-12-16&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;信息检索、分类、识别、翻译等领域两个最基本指标是召回率(Recall Rate)和准确率(Precision Rate)，召回率也叫查全率，准确率也叫查准率，概念公式:
召回率(Recall)    = 系统检索到的相关文件 / 系统所有相关的文件总数
准确率(Precision) = 系统检索到的相关文件 / 系统所有检索到的文件总数
注意：准确率和召回率是互相影响的，理想情况下肯定是做到两者都高，但是一般情况下准确率高、召回率就低，召回率低、准确率高，当然如果两者都低，那是什么地方出问题了。一般情况，用不同的阀值，统计出一组不同阀值下的精确率和召回率，如下图：
&lt;a href=&#34;http://hi.csdn.net/attachment/201106/14/0_1308034738ZLr8.gif&#34;&gt;图片&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hexo博客更换电脑的正确姿势</title>
      <link>https://jintianme.github.io/post/Hexo%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</link>
      <pubDate>Mon, 12 Dec 2016 10:47:07 +0000</pubDate>
      
      <guid>https://jintianme.github.io/post/Hexo%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</guid>
      <description>

&lt;p&gt;hexo指南
&lt;!-- more --&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;本文由中南大学较为牛逼的研究生金天同学原创，欢迎转载，但是请保留这段版权信息，如果你对文章有任何疑问，欢迎微信联系我：jintianiloveu。牛逼大神一一为你解答！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;hexo如何实现更换电脑继续写博客&#34;&gt;Hexo如何实现更换电脑继续写博客&lt;/h3&gt;

&lt;p&gt;这个问题有点蛋疼，不是麻烦而是如果你不知道一些细节会有莫名其妙的错误。我现在不仅仅是实现了两台电脑更新博客，同时我的Mac笔记上甚至运行了两个不同的hexo博客，分别部署到了两个不同的github账号中。接下来就记录一下更新过程。
首先是加入你有一台台式电脑，在实验室，那么哪一天你离开了实验室你就要把博客搬到自己的笔记本，我们接下来就处理这个问题。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;首先把原来电脑的博客git推送到一个Hexo-Blog——Resources远程仓库中&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ok这个步骤其实很简单，直接在实验室的台式电脑hexoblog目录下git init，然后在github新建一个放源文件的仓库，推送进去即可&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;将远程博客同步到自己笔记本&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个步骤也简单，直接克隆
接下来是重点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;初始化新的hexo&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来你要把克隆的原来电脑的源文件重新安装hexo，但是实际上你不安装也是可以直接运行的，但是我发现如果什么都不处理，直接deploy会把所有源文件push上去，而不是生成的静态文件。
正确的姿势应该是：
首先把目录下的.deploygit这个文件夹删除，其他的db.json什么的也删除，什么public的也删除，然后重新安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install hexo
npm install hexo-deployer-git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后记得执行hexo clean这个命令。一定要clean，然后再hexo d -g&lt;/p&gt;

&lt;h3 id=&#34;hexo实现一台电脑两个git账号管理两个博客&#34;&gt;hexo实现一台电脑两个git账号管理两个博客&lt;/h3&gt;

&lt;p&gt;实际上这个我也是一种尝试，有两个办法，一种是生成一个id_rsa密匙，然后再两个github账号中都添加这个密匙，这样直接就可以deploy了。
不过这种办法并不好，另外一种办法是生成两个密匙，分别命名。然后再用一个config来管理：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/.ssh
vi config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加以下代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host github.com
    HostName github.com
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/id_rsa

Host coding.net
    HostName coding.net
    PreferredAuthentications pulickey
    IdentityFile ~/.ssh/id_rsa_lewisjin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应该就可以了。
&lt;strong&gt;更新ssh publickey 之后一定记得 ssh-add id_rsa,否则ssh依旧会提示登不上的！！！&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>夜有所思</title>
      <link>https://jintianme.github.io/post/%E5%A4%9C%E6%9C%89%E6%89%80%E6%80%9D/</link>
      <pubDate>Sun, 11 Dec 2016 23:35:30 +0000</pubDate>
      
      <guid>https://jintianme.github.io/post/%E5%A4%9C%E6%9C%89%E6%89%80%E6%80%9D/</guid>
      <description>

&lt;p&gt;本文是我的一个随笔
&lt;!-- more --&gt;
&amp;gt; 你有过思念的感觉吗？&lt;/p&gt;

&lt;h3 id=&#34;桃花谢了春红-太匆匆-却是朝来风雨晚来风&#34;&gt;桃花谢了春红，太匆匆，却是朝来风雨晚来风&lt;/h3&gt;

&lt;p&gt;岁月悄然流淌，我们也在成长，可是在成长的岁月里那些留给我们的感动我们还记得多少呢？以前只有离别家乡的时候才会与依依不舍之情，现在离开的这个地方不是家乡，却有着跟家乡一样的感觉，有着牵挂的人，这也许就是一种魂牵梦绕的情愫吧。
今天把博客从实验室搬到了自己的笔记本，宾至如归，所有的事情我都想好好的握在手里，不至于等到失去之后我才后悔莫及。
好吧这其实是一个测试，测试一下博客有没有迁移成功，也不能太伤感了，哎。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>git命令删除当前远程仓库依赖</title>
      <link>https://jintianme.github.io/post/git%E5%91%BD%E4%BB%A4%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%BE%9D%E8%B5%96/</link>
      <pubDate>Sun, 11 Dec 2016 21:51:12 +0000</pubDate>
      
      <guid>https://jintianme.github.io/post/git%E5%91%BD%E4%BB%A4%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%BE%9D%E8%B5%96/</guid>
      <description>

&lt;p&gt;git命令简介
&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;学会使用git命令，不仅仅可以远程操控一切，还可以节省很多体力劳动，比如插优盘拔优盘..
&amp;gt; 本文由中南大学较为牛逼的研究生金天同学原创，欢迎转载，但是请保留这段版权信息，如果你对文章有任何疑问，欢迎微信联系我：jintianiloveu。牛逼大神一一为你解答！&lt;/p&gt;

&lt;h3 id=&#34;git命令使用简介&#34;&gt;git命令使用简介&lt;/h3&gt;

&lt;p&gt;git命令其实非常简单，但是网上的教程大多数都是乱七八糟，误人子弟，其实要我来讲，只需要记住一个概念：&lt;strong&gt;git是将本地仓库对接远程仓库的工具&lt;/strong&gt;，这里记住有两个名词，一个本地仓库一个远程仓库，那么必然是两个仓库，很多人在后面遇到很多问题都是不明白这两个概念造成的。
使用之前首先第一步用git初始化，然后把所有文件添加到本地仓库，注意一定要添加之本地仓库，而在添加本地仓库的时候，如果你的代码有修改，那么就得commit，所谓commit就是执行，确保执行，加上你的注解，防止后面你不知道改了哪个地方。
然后才是git remote add origin &lt;a href=&#34;http://github.com/.&#34;&gt;http://github.com/.&lt;/a&gt;.
最后才是push
所以说一般的git使用套路是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git init
git add .
git commit -a -m &amp;quot;first commit&amp;quot;
git remote add origin http://github.com/jinfagang/Morph.git
git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这里为什么要添加到origin而不是brigin或者其他名字，其实是可以的，只是我们习惯拔本地仓库明明为origin。&lt;/p&gt;

&lt;h3 id=&#34;git修改远程仓库&#34;&gt;git修改远程仓库&lt;/h3&gt;

&lt;p&gt;有时候我们需要修改一下远程仓库的依赖，很简单&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git remote remove origin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接拔本地的remote仓库删除即可。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android开车第一弹-MaterialDesign设计规范</title>
      <link>https://jintianme.github.io/post/Android%E5%BC%80%E8%BD%A6%E7%AC%AC%E4%B8%80%E5%BC%B9-MaterialDesign%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</link>
      <pubDate>Sun, 04 Dec 2016 22:10:02 +0000</pubDate>
      
      <guid>https://jintianme.github.io/post/Android%E5%BC%80%E8%BD%A6%E7%AC%AC%E4%B8%80%E5%BC%B9-MaterialDesign%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</guid>
      <description>

&lt;p&gt;本文是Android学的一个随笔
&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;会iOS再来学Android，一切就像行云流水一样融会贯通，从某种意义上来讲，Android比iOS简单，iOS能够实现更精细的布局，但是也更复杂。Android大条随意，这也是为什么我想学习它的原因。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;本文由中南大学较为牛逼的研究生金天同学原创，欢迎转载，但是请保留这段版权信息，如果你对文章有任何疑问，欢迎微信联系我：jintianiloveu。牛逼大神一一为你解答！&lt;/p&gt;

&lt;h3 id=&#34;自定义toolbar&#34;&gt;自定义ToolBar&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;学习Android一个很重要的问题就是自定义一个美观的toolbar，而很多人不懂得设计规范，各种直接拖按钮上toolbar，太猥琐了。人家google明明有标准的规范为什么不用，非得自作聪明的乱加。
好了不多说了，自顶一个一个toolbar步骤如下：
* &lt;strong&gt;更改主题为NoActionBar&lt;/strong&gt;
这是第一步，也是最重要的一步，要用toolbar，首先把Actionbar去掉。去掉的方法也很简单，直接设置styles.xml：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style name=&amp;quot;AppTheme&amp;quot; parent=&amp;quot;Theme.AppCompat.Light.NoActionBar&amp;quot;&amp;gt;
    &amp;lt;!-- Customize your theme here. --&amp;gt;
    &amp;lt;item name=&amp;quot;colorPrimary&amp;quot;&amp;gt;@color/colorPrimary&amp;lt;/item&amp;gt;
    &amp;lt;item name=&amp;quot;colorPrimaryDark&amp;quot;&amp;gt;@color/colorPrimaryDark&amp;lt;/item&amp;gt;
    &amp;lt;item name=&amp;quot;colorAccent&amp;quot;&amp;gt;@color/colorAccent&amp;lt;/item&amp;gt;
    &amp;lt;item name=&amp;quot;android:actionMenuTextColor&amp;quot;&amp;gt;@color/colorWhite&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样以来又有个问题，这里设置了主题是light，那么toolbar的文字就会变成黑色，我们进一步定义一个toolbar的theme:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style name=&amp;quot;ToolbarTheme&amp;quot; parent=&amp;quot;@style/ThemeOverlay.AppCompat.ActionBar&amp;quot;&amp;gt;
    &amp;lt;item name=&amp;quot;actionMenuTextColor&amp;quot;&amp;gt;@android:color/white&amp;lt;/item&amp;gt;
    &amp;lt;item name=&amp;quot;android:textColorPrimary&amp;quot;&amp;gt;@android:color/white&amp;lt;/item&amp;gt;
    &amp;lt;item name=&amp;quot;android:popupMenuStyle&amp;quot;&amp;gt;@style/Platform.ThemeOverlay.AppCompat.Light&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里定义了toolbar主题的文字颜色。你设置了NoActionbar之后，实际上在AndroidStudio上的designer就没有ActionBar了，还需要从空间中拖入一个toolbar到actiivity_main.xml，这样的话我们就实现了，toolbar。但是只是一个toolbar我们还没有加入menu&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;添加menu&lt;/strong&gt;
添加menu，先不管代码，新建一个menu的布局文件，直接拖入menu即可，如果你要想menu在toolbar显示呢就设置
&lt;code&gt;
app:showAsAction=&amp;quot;always&amp;quot;
&lt;/code&gt;
AndroidStudio现在有个好处就是都可以直接在界面上设置了，甚至不用写代码。
然后我们在activity java文件中写代码：
&lt;code&gt;
Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
setSupportActionBar(toolbar);
&lt;/code&gt;
这两行代码就设置了我们的toolbar为actionbar了。接着处理menu事件，首先导入包：
&lt;code&gt;
import android.view.Menu;
import android.view.MenuItem;
&lt;/code&gt;
不导入包，ide不会提示你重写哪几个方法。所以还是导入一下比较好。接着我们就可以开车了：
&lt;code&gt;
public boolean onCreateOptionsMenu(Menu menu){
getMenuInflater().inflate(R.menu.toolbar_menu, menu);
return true;
}
public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()){
    case R.id.settings:
        System.out.println(&amp;quot;====&amp;gt;settings&amp;quot;);
        break;
    case R.id.more:
        System.out.println(&amp;quot;=====&amp;gt;more&amp;quot;);
        break;
    case R.id.about:
        System.out.println(&amp;quot;====&amp;gt;about&amp;quot;);
        break;
    default: break;
}
return true;
}
&lt;/code&gt;
这两个方法就可以实现那啥了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用recyclerview&#34;&gt;使用recyclerview&lt;/h3&gt;

&lt;p&gt;学习一个移动操作系统必须得学习list的使用，在安卓中就是recyclerview，在iOS中就是tableview和collectionview。扯远了，安卓使用recyclerview其实也是很简单的。
* &lt;strong&gt;在主界面中拖入一个recyclerview&lt;/strong&gt;
这个不需要多说，有手的人都能托，而且大家的手又都这么健壮&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;新建一个recyclerview item的布局文件&lt;/strong&gt;
我不得不说一下安卓跟iOS开发的巨大不同啊，iOS讲究的是精细，美观，所以布局是个很头疼的问题，而安卓就不一样，不管你怎么拖好像它都能帮你自动适配，不过安卓也很难做出iOS那样精细的页面，不过没有关系，好在我们的安卓手机屏幕都很大，加上我们的material design还是非常美观的，也非常符合这种设计语言和风格。、
布局文件随便拖入几个控件或者textview，接下来我们就写控制器来控制他们。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;写适配器，类似于iOS中的tableviewcellcontroller&lt;/strong&gt;
适配器也很简单，首先你要导入包，否则不会提示你重写的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import android.content.Context;
import android.support.v7.widget.RecyclerView;
import android.support.v7.widget.RecyclerView.*;
import android.view.LayoutInflater;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;貌似这些包都要用到。没有关系，接下来我们就重写方法了，一个完整的适配器例子如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class RecyclerViewAdapter extends RecyclerView.Adapter&amp;lt;RecyclerViewAdapter.MyViewHolder&amp;gt; {

private Context context;
private List&amp;lt;String&amp;gt; data;

public RecyclerViewAdapter(Context context, List&amp;lt;String&amp;gt; data){
    this.context = context;
    this.data = data;
}

public RecyclerViewAdapter.MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType){
    View view = LayoutInflater.from(context).inflate(R.layout.list_item_layout, null);
    return new MyViewHolder(view);
}

public void onBindViewHolder(RecyclerViewAdapter.MyViewHolder holder, int position){
    String res = data.get(position);
    holder.tv1.setText(&amp;quot;nihao&amp;quot;);
}
public int getItemCount(){
    return 20;
}



class MyViewHolder extends ViewHolder{
    TextView tv1;
    public MyViewHolder(View view){
        super(view);
        tv1 = (TextView) view.findViewById(R.id.textView);
    }

}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;最后一部，找到recyclerview，设置适配器&lt;/strong&gt;
最后一步很简单，直接贴代码了
```
RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recyclerView);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ArrayList&lt;String&gt; dataArray = new ArrayList&lt;String&gt;();
for (int i = 1; i&amp;lt;50; i++){
    dataArray.add(&amp;ldquo;hello&amp;rdquo;);
}&lt;/p&gt;

&lt;p&gt;LinearLayoutManager manager = new LinearLayoutManager(this);
manager.setOrientation(LinearLayoutManager.VERTICAL);
recyclerView.setLayoutManager(manager);
recyclerView.setItemAnimator(new DefaultItemAnimator());&lt;/p&gt;

&lt;p&gt;RecyclerViewAdapter adapter = new RecyclerViewAdapter(this, dataArray);
recyclerView.setAdapter(adapter);
```&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mxnet开车教程series1-mnist上手</title>
      <link>https://jintianme.github.io/post/mxnet%E5%BC%80%E8%BD%A6%E6%95%99%E7%A8%8Bseries1-mnist%E4%B8%8A%E6%89%8B/</link>
      <pubDate>Sat, 03 Dec 2016 21:50:54 +0000</pubDate>
      
      <guid>https://jintianme.github.io/post/mxnet%E5%BC%80%E8%BD%A6%E6%95%99%E7%A8%8Bseries1-mnist%E4%B8%8A%E6%89%8B/</guid>
      <description>

&lt;p&gt;mxnet入门中文教程，让我们从mnist果蝇数据集开始开车
&lt;!-- more --&gt;
&amp;gt; 本文由中南大学较为牛逼的研究生金天同学原创，欢迎转载，但是请保留这段版权信息，如果你对文章有任何疑问，欢迎微信联系我：jintianiloveu。牛逼大神一一为你解答！&lt;/p&gt;

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;最近搭建起了深度学习环境，mxnet被亚马逊钦定为官方的机器学习库，加上mxnet快速，代码清晰的特点，我赶紧乘上了mxnet快车，准备以mxnet为基础开始一些理论研究和产品实现。然而&amp;hellip;.mxnet搭建过程还是有点麻烦的，尤其是对于对编译过程不是非常熟悉的同学，这一点和caffe有点像，不过这不是问题，在本博客前面几篇文章对此有一个专门的教程，大家可以去看看，欢迎评论转载。这篇文章是mxnet开车教程的第一弹，让我们从果蝇数据集开始下手。&lt;/p&gt;

&lt;h3 id=&#34;开车&#34;&gt;开车！&lt;/h3&gt;

&lt;p&gt;二话不多说，开始开车，作为一名深度学习老司机，我们应该要学会果蝇数据集的正确下载方式，我这里就不贴了，去Lecun的官网下载。下载之后解压，你将会看到四个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;t10k-images.idx3-ubyte
t10k-labels.idx1-ubyte
train-images.idx3-ubyte
train-labels.idx1-ubyte
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是训练集和测试集的数据和标签，很多人一看不知道这是什么鬼，其实我也不知道这是什么鬼，反正是一种文件格式就对了。不多说了直接上代码，开车之前先导入包：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import struct
import numpy as np
import matplotlib.pyplot as plt
import mxnet as mx
import logging
logging.getLogger().setLevel(logging.DEBUG)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;哪个包缺少安装哪个，玩mxnet你不要告诉我你还没有安装mxnet，快去我的另外一片博文看教程安装。&lt;/p&gt;

&lt;h3 id=&#34;读取mnist数据集的正确姿势&#34;&gt;读取mnist数据集的正确姿势&lt;/h3&gt;

&lt;p&gt;接下来我有必要传授大家读取mnist数据集的正确方式了，网上流传的各种方法都是瞎扯淡，不懂得科学内涵（手动装逼）。正确的读取方式我谢了两个函数，一个读取label，一个读取image：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def read_mnist_label(file_name):
    bin_file = open(file_name, &#39;rb&#39;)
    magic, num = struct.unpack(&amp;quot;&amp;gt;II&amp;quot;, bin_file.read(8))
    label = np.fromstring(bin_file.read(), dtype=np.int8)
    return label

def read_mnist_image(file_name):
    bin_file = open(file_name, &#39;rb&#39;)
    magic, num, rows, cols = struct.unpack(&amp;quot;&amp;gt;IIII&amp;quot;, bin_file.read(16))
    image = np.fromstring(bin_file.read(), dtype=np.uint8).reshape(num, rows, cols)
    return image
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将我们下载的文件传进去，就能得到label，images的输出，应该都是numpy.array的格式。&lt;/p&gt;

&lt;h3 id=&#34;测试图片&#34;&gt;测试图片&lt;/h3&gt;

&lt;p&gt;我们写个显示图片的函数把：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def plot_image(image_array):
    plt.imshow(image_array, cmap=&#39;gray&#39;)
    plt.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入图片矩阵，画出图片。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val_img = read_mnist_image(&#39;t10k-images.idx3-ubyte&#39;)
plot_image(val_img[0])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就把测试集的第一张图片显示出来了。&lt;/p&gt;

&lt;h3 id=&#34;搭建mxnet网络&#34;&gt;搭建mxnet网络&lt;/h3&gt;

&lt;p&gt;这部分直接根据官网的来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;batch_size = 100
train_iter = mx.io.NDArrayIter(to4d(train_img), train_lbl, batch_size, shuffle=True)

val_iter = mx.io.NDArrayIter(to4d(val_img), val_lbl, batch_size)

data = mx.sym.Variable(&#39;data&#39;)
data = mx.sym.Flatten(data=data)

fc1 = mx.sym.FullyConnected(data=data, name=&#39;fc1&#39;, num_hidden=128)
act1 = mx.sym.Activation(data=fc1, name=&#39;relu1&#39;, act_type=&amp;quot;relu&amp;quot;)

fc2 = mx.sym.FullyConnected(data=act1, name=&#39;fc2&#39;, num_hidden=64)
act2 = mx.sym.Activation(data=fc2, name=&#39;relu2&#39;, act_type=&amp;quot;relu&amp;quot;)

fc3 = mx.sym.FullyConnected(data=act2, name=&#39;fc3&#39;, num_hidden=10)
mlp = mx.sym.SoftmaxOutput(data=fc3, name=&#39;softmax&#39;)

shape = {&amp;quot;data&amp;quot;: (batch_size, 1, 28, 28)}
# mx.viz.plot_network(symbol=mlp, shape=shape)

model = mx.model.FeedForward(
    ctx=mx.gpu(0),
    symbol=mlp,
    num_epoch=4,
    learning_rate=0.1
)
model.fit(
    X=train_iter,
    eval_data=val_iter,
    batch_end_callback=mx.callback.Speedometer(batch_size, 200)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;预测&#34;&gt;预测&lt;/h3&gt;

&lt;p&gt;最后最重要的部分来了，那就是预测：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;predict_img = val_img[0].astype(np.float32).reshape((1, 1, 28, 28))/255.0
prob = model.predict(predict_img)[0]
print(&#39;prob:&#39;, prob)
print(&#39;Classified as {0} with probability {1}&#39;.format(prob.argmax(), max(prob)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Classified as 7 with probability 0.9959895014762878
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明我们的预测准确度还是非常高的啊！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu下编译opencv并生成python链接库详细教程-吐血编译系列</title>
      <link>https://jintianme.github.io/post/Ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91opencv%E5%B9%B6%E7%94%9F%E6%88%90python%E9%93%BE%E6%8E%A5%E5%BA%93%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B-%E5%90%90%E8%A1%80%E7%BC%96%E8%AF%91%E7%B3%BB%E5%88%97/</link>
      <pubDate>Sat, 03 Dec 2016 10:20:47 +0000</pubDate>
      
      <guid>https://jintianme.github.io/post/Ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91opencv%E5%B9%B6%E7%94%9F%E6%88%90python%E9%93%BE%E6%8E%A5%E5%BA%93%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B-%E5%90%90%E8%A1%80%E7%BC%96%E8%AF%91%E7%B3%BB%E5%88%97/</guid>
      <description>

&lt;p&gt;本文将解决的是opencv这个洪水猛兽，opencv功能强大，但是无论在ubuntu下还是在windows下编译都非常麻烦，本文将编译它，并生成python调用库。哥搞了好几天才搞定，shit！
&lt;!-- more --&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;本文由中南大学较为牛逼的研究生金天同学原创，欢迎转载，但是请保留这段版权信息，如果你对文章有任何疑问，欢迎微信联系我：jintianiloveu。牛逼大神一一为你解答！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;前言&#34;&gt;前言&lt;/h4&gt;

&lt;p&gt;opencv3.1 Ubuntu16.04 python3.5 编译完成，python下可以直接调用。先说一下，编译源码并生成python可以调用的库，检查方法是看看是否在/usr/local/lib/python3.5/dist-packages下有cv2.python-35m-x86_64-linux-gnu.so的库，如果编译生成了，说明可以在python中调用使用了，其他语言应该也差不多，但是网上的一些教程要么过时要么没有提醒你注意重要步骤甚至有些教程还是啥鸡巴扯淡的，蛋疼，我把我配置编译的过程记录一些，让后来者少走一些弯路，如果一些地方你不注意真的很容易浪费时间在各种编译错误上。首先致谢这篇英文文章，人家外国人写博客说的很清楚，不像国人写个博客妈的缺胳膊少腿。&lt;/p&gt;

&lt;h4 id=&#34;先说几句&#34;&gt;先说几句&lt;/h4&gt;

&lt;p&gt;本教程主要是教大家在ubuntu16.04 上编译python3.5版本的opencv3.1，如果你要是其他系统或者python版本步骤应该差不多，但是一定要小心修改，多尝试。整个过程容易出错以及将会导致的错误我都会粗体警示，毕竟我是踩着坑过来的。&lt;strong&gt;在编译python版本的opencv库之前一定要安装numpy，特此提示，后面的步骤不包含这一步&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;安装过程&#34;&gt;安装过程&lt;/h4&gt;

&lt;h5 id=&#34;step1-各种apt先get一下-安装需要的依赖&#34;&gt;Step1 各种apt先get一下，安装需要的依赖&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;sudo apt update
sudo apt install build-essential cmake pkg-config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中cmake是一定要安装的，apt是最简单的安装方式，pkg-config一般系统会自带，我们不管狂安装就是&lt;/p&gt;

&lt;h5 id=&#34;step2-安装opencv需要的图片编码库-视频编码库等库&#34;&gt;Step2 安装opencv需要的图片编码库、视频编码库等库&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev
sudo apt-get install libxvidcore-dev libx264-dev
sudo apt-get install libatlas-base-dev gfortran
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面两句是安装以来的编码库，包括图片和视频，最后一行是安装优化算法库atlas。&lt;/p&gt;

&lt;h5 id=&#34;step3-极其重要的一步-安装python开发库-如果缺少这个步骤无法生成python的调用链接&#34;&gt;Step3 &lt;strong&gt;极其重要的一步，安装python开发库，如果缺少这个步骤无法生成python的调用链接&lt;/strong&gt;&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install python2.7-dev python3.5-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里python2.7和3.5一起安装了，防止后面有人要安装2.7的版本。&lt;/p&gt;

&lt;h5 id=&#34;step4-下载opencv源码文件&#34;&gt;Step4 下载opencv源码文件&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;cd ~
git clone https://github.com/opencv/opencv.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从这里下载最新的opencv版本，然后我们就会在home目录下看到opencv源代码文件了。&lt;/p&gt;

&lt;h5 id=&#34;step5-开始编译和安装&#34;&gt;Step5 开始编译和安装&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;cd opencv
mkdir build
cd build
cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D INSTALL_PYTHON_EXAMPLES=ON -D PYTHON_EXECUTABLE=/usr/bin/python -D WITH_CUDA=OFF -D BUILD_EXAMPLES=ON  ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里我要解释一下，cmake后面的参数非常重要，决定了编译是否可以成功，其中比较重要的两个参数：&lt;strong&gt;PYTHON_EXECUTABLE&lt;/strong&gt; &lt;strong&gt;WITH_CUDA&lt;/strong&gt;,前者是告诉编译程序你的pyton解释器的路径，这个路径默认就是你在terminal输入which python弹出的路径，不管是python2.7还是3.5都是这个路径，后面这个是说你编译的时候要不要用CUDA加速，反正我是没有编译成功，所以直接放弃了，如果你有CUDA配置好了，可以参考下面这条命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D INSTALL_PYTHON_EXAMPLES=ON -D PYTHON_EXECUTABLE=/usr/bin/python -D CUDA_GENERATION=Auto -D BUILD_EXAMPLES=ON ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数CMAKE_BUILD_TYPE CMAKE_INSTALL_PREFIX是说你的cmake的安装路径，cmake默认是安装在/usr/local下的。ok，然后enter
先cmake一下。在这个过程中你可能会遇到一些问题，一般可以百度到解决方案，比如可能会遇到一个问题就是提示没有ippicv文件，说是文件校验码不对，这个时候莫慌，直接从网上搜索ippicv这个文件放到opencv/3rdparty/ippicv下即可，同时build文件夹下也复制一个（build文件夹和opencv下的目录结果一样的），然后在cmake就没有问题了。
OK，接着我们make&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make -j8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候有问题就百度一下，都能解决，一般情况下不会遇到问题，只要你的cmake参数设置没有写错。
完成之后在install&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK，我们这就编译好了opencv的库。&lt;/p&gt;

&lt;h4 id=&#34;来玩一玩opencv&#34;&gt;来玩一玩opencv&lt;/h4&gt;

&lt;p&gt;千辛万苦终于编译好了，得好好玩玩这个opencv，这里哥带领大家玩一个牛逼点的例子：&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu大手术-更换home的挂载分区获取更大空间</title>
      <link>https://jintianme.github.io/post/Ubuntu%E5%A4%A7%E6%89%8B%E6%9C%AF-%E6%9B%B4%E6%8D%A2home%E7%9A%84%E6%8C%82%E8%BD%BD%E5%88%86%E5%8C%BA%E8%8E%B7%E5%8F%96%E6%9B%B4%E5%A4%A7%E7%A9%BA%E9%97%B4/</link>
      <pubDate>Sat, 03 Dec 2016 09:48:43 +0000</pubDate>
      
      <guid>https://jintianme.github.io/post/Ubuntu%E5%A4%A7%E6%89%8B%E6%9C%AF-%E6%9B%B4%E6%8D%A2home%E7%9A%84%E6%8C%82%E8%BD%BD%E5%88%86%E5%8C%BA%E8%8E%B7%E5%8F%96%E6%9B%B4%E5%A4%A7%E7%A9%BA%E9%97%B4/</guid>
      <description>

&lt;p&gt;Ubuntu系统安装时由于年少无知瞎几把设置分区，结果最后导致空间不够用，不过不用担心，本教程教你如何在不装系统的情况之下对分区进行修改
&lt;!-- more --&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;本文由中南大学较为牛逼的研究生金天同学原创，欢迎转载，但是请保留这段版权信息，如果你对文章有任何疑问，欢迎微信联系我：jintianiloveu。牛逼大神一一为你解答！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;准备一个更大的分区&#34;&gt;准备一个更大的分区&lt;/h4&gt;

&lt;p&gt;首先当然最要紧的是准备一个更大的分区，这里我建议大家选择一个分区大小在50G以上的分区，作为开发人员是真的需要这么多空间，否则到后面又会不够用。（原则上当初安装系统的时候就应该root和home都设置为50G以上最好）
更换分区大手术的思路是这样的：
* &lt;strong&gt;将准备的新硬盘挂载到/media/home目录下&lt;/strong&gt;
* &lt;strong&gt;将原/home目录下的文件全部同步到/media/home目录下，这就相当于复制了一个home到新硬盘上&lt;/strong&gt;
* &lt;strong&gt;更改/media/home挂载为/home&lt;/strong&gt;
* &lt;strong&gt;(可选)备份/home到/old_home以防不测&lt;/strong&gt;
* &lt;strong&gt;重启系统进入新home&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;开始备份工作&#34;&gt;开始备份工作&lt;/h4&gt;

&lt;p&gt;接着我们打开/etc/fstab文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo gedit /etc/fstab
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时候你会发现这些东西：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# &amp;lt;file system&amp;gt; &amp;lt;mount point&amp;gt;   &amp;lt;type&amp;gt;  &amp;lt;options&amp;gt;       &amp;lt;dump&amp;gt;  &amp;lt;pass&amp;gt;
# / was on /dev/sda11 during installation
UUID=48d1bdc4-b4ab-4496-880c-0298135dbbf2 /               ext4    errors=remount-ro 0       1
# /boot was on /dev/sda12 during installation
UUID=6dbeefea-6ea4-4ab7-8a75-5a91e5e5a45c /boot           ext4    defaults        0       2
# /boot/efi was on /dev/sda1 during installation
UUID=0A0D-7DD0  /boot/efi       vfat    umask=0077      0       1
# /home was on /dev/sda7 during installation
#UUID=5d56eef4-8f46-40ab-8ace-50122eb0bc27 /home           ext4    defaults        0       2
# change home mount to size80G disk
UUID=b5a9ca3a-fba0-46aa-9249-4fe8c94e2f9a /home           ext4    defaults        0       2
# swap was on /dev/sda6 during installation
UUID=563897f4-5404-466d-953f-af78250e85d0 none            swap    sw              0       0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大家看我加粗的一行，这是我之前的home挂在分区，下面的是新的home分区，放到你的情况就应该先把原来的home分区设置注释掉，复制一行，以免出面出错忘记了初始设置，然后我们要查看一下自己硬盘的UUID，&lt;strong&gt;UUID查看方式，不能出错否则挂载就错了&lt;/strong&gt;,新开一个terminal，输入以下代码来查看：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo blkid
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时候你就应该可以看到/dev/sda11之类的后面带着UUID，你要重新挂载的硬盘在哪个sda呢，你直接用ubuntu系统的disk软件来看，然后找到对应的UUID，复制以下，再回到刚才打开的fstab文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# (identifier)  (location, eg sda5)   (format, eg ext3 or ext4)      (some settings)
UUID=YOURUUID   /media/home    ext4          defaults       0       2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回到termminal，输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mkdir /media/home
sudo mount -a

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后关机重启以下，&lt;strong&gt;记住这里要重启以下&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;开机进入Ubuntu，这时候我们就把新硬盘挂载到了/media/home路径下，不信你可以去/media下面查看，是有一个home文件夹，这个对应的物理路径就是你的新硬盘或者新分区。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OK,我们完成了挂载工作，接下来把文件同步复制到新分区&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo rsync -aXS --progress --exclude=&#39;/*/.gvfs&#39; /home/. /media/home/.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等待文件复制完成，需要蛮久。&lt;/p&gt;

&lt;h4 id=&#34;更换为新的home挂载&#34;&gt;更换为新的home挂载&lt;/h4&gt;

&lt;p&gt;修改fstab文件，到这你就差一步了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo /etc/fstab
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把之前我们加的/media/home修改为/home&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# (identifier)  (location, eg sda5)   (format, eg ext3 or ext4)      (some settings)
UUID=YOURUUID   /home    ext4          defaults       0       2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK,&lt;strong&gt;重启&lt;/strong&gt;，进入ubuntu你会发现所有的&lt;strong&gt;一切还和原来一样&lt;/strong&gt;，打开nautilus，查看以下home分区发现空间变大了！这就是linux，你可以尽情的做手术依旧保持着健壮的生命力。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>